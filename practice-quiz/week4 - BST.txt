Q1. Java autoboxing and equals().
Consider two double values a and b and their corresponding <tt>Double</tt> values x and y.

    Find values such that (a==b) is true but x.equals(y) is false.
    Find values such that (a==b) is false but x.equals(y) is true.

A1.

Primitive values of 0.0 and -0.0 are equal but the corresponding Double objects aren't.
By definition, the primitive for Nan is not equal but the corresponding Double objets are.


Q2. Check if a binary tree is a BST.
Given a binary tree where each Node contains a key, determine whether it is a binary search tree.
Use extra space proportional to the height of the tree.

A2.
boolean isBST(Node node) {

    if(node == null) {
        return true
    }

    boolean leftOk = node.left == null || node.value > node.left.value
    boolean rightOk = node.right == null || node.value < node.right.value

    return leftOk && rightOk && isBST(node.left) && isBST(node.right)
}

Q3. Inorder traversal with constant extra space.
Design an algorithm to perform an inorder traversal of a binary search tree using only a constant amount of extra space.

A3.
inOrderTraversal(Node node){
    if(node == null) return;

    inOrderTraversal(node.left)
    println node.key
    inOrderTraversal(node.right)
}