Q1.Dynamic median.
Design a data type that supports insert in logarithmic time, find-the-median in constant time, and remove-the-median in logarithmic time.

A1.
Keep two heaps: a max oriented heap for the bellow to the median elements (left) and a  min oriented for the above of the median elements (right).
An extra variable for the median. To be consistent the num of elements to the left must be equal to the num of elements in the right (with tolerance os + - 1).
When inserting a new value check if it is greater then median, if so insert to right heap. Insert to he left otherwise.
If the size of the right heap gets greater + 1 of the left heap rotate left:
left.insert(median)
mediam = right.getMax()

rotate right otherwise:
right.insert(median)
median = left.getMin()

code:
class DynamicMedian {

    Integer median;
    MinPQ<Integer> right
    MaxPQ<Integer> left

    public DynamicMedian() {
        right = new MinPQ<>()
        left = new MaxPQ<>()
    }

    void insert(int val) {

        if (median == null) {
            median = val
        } else if (val > median) {

            right.insert(val)

            if (right.size() > left.size() + 1) {
                rotateLeft()
            }
        } else {

            left.insert(val)

            if (left.size() > right.size() + 1) {
                rotateRight()
            }
        }
    }

    private void rotateLeft() {
        left.insert(median)
        median = right.delMin()
    }

    private void rotateRight() {
        right.insert(median)
        median = left.delMax()
    }

    int peek() {
        median
    }

    int delMedian() {

        int tmp = median
        if (left.size() > right.size()) {
            median = left.delMax()
        } else {
            median = right.delMin()
        }

        return tmp
    }
}


Q2.Randomized priority queue.
Describe how to add the methods sample() and delRandom() to our binary heap implementation.
The two methods return a key that is chosen uniformly at random among the remaining keys, with the latter method also removing that key.
The sample() method should take constant time;
the delRandom() method should take logarithmic time.
Do not worry about resizing the underlying array.

A2.
Consider that the binary heap is impemented in an array. For sampling just pick a random number from 0 to N-1 and return it.
For removing a random element, pick a random number and swap it with the last element in the heap.
Remove the last element, that will be the returned and removed element.
Apply the sink operation in the swaped element so it can be placed in its right position

